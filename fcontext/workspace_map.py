"""fcontext workspace map — auto-generate a structural overview."""
from __future__ import annotations

import os
from collections import Counter, defaultdict
from pathlib import Path

SKIP_DIRS = {
    ".git", ".hg", ".svn", ".venv", "venv", "__pycache__",
    "node_modules", "dist", "build", "out", ".next",
    ".fcontext",
}


def generate_workspace_map(root: Path) -> str:
    """Scan workspace and produce a Markdown map."""
    lines: list[str] = []
    lines.append("# Workspace Map\n")
    lines.append(f"> Auto-generated by `fcontext init`\n")
    lines.append(f"> Root: {root}\n")

    # 1. Directory tree (depth 2)
    lines.append("## Directory Structure\n")
    lines.append("```")
    lines.extend(_dir_tree(root, max_depth=2))
    lines.append("```\n")

    # 2. File type breakdown
    lines.append("## File Types\n")
    ext_counts = Counter()
    domain_exts: dict[str, Counter] = defaultdict(Counter)

    for dirpath, dirnames, filenames in os.walk(root):
        dirnames[:] = [d for d in dirnames if d not in SKIP_DIRS and not d.startswith(".")]
        rel_dir = Path(dirpath).relative_to(root)
        domain = rel_dir.parts[0] if rel_dir.parts else "."

        for fname in filenames:
            if fname.startswith("."):
                continue
            ext = Path(fname).suffix.lower() or "(no ext)"
            ext_counts[ext] += 1
            domain_exts[domain][ext] += 1

    lines.append("| Extension | Count |")
    lines.append("|-----------|-------|")
    for ext, count in ext_counts.most_common(20):
        lines.append(f"| `{ext}` | {count} |")
    lines.append("")

    # 3. Domain summary
    lines.append("## Domains\n")
    for domain in sorted(domain_exts.keys()):
        exts = domain_exts[domain]
        total = sum(exts.values())
        top_exts = ", ".join(f"{e}({c})" for e, c in exts.most_common(5))
        lines.append(f"- **{domain}/** — {total} files — {top_exts}")
    lines.append("")

    return "\n".join(lines)


def _dir_tree(root: Path, max_depth: int) -> list[str]:
    """Generate a simple directory tree up to max_depth."""
    result = [f"{root.name}/"]

    def _walk(path: Path, prefix: str, depth: int):
        if depth >= max_depth:
            return
        try:
            entries = sorted(path.iterdir(), key=lambda p: (not p.is_dir(), p.name.lower()))
        except PermissionError:
            return

        dirs = [e for e in entries if e.is_dir() and e.name not in SKIP_DIRS and not e.name.startswith(".")]
        files = [e for e in entries if e.is_file() and not e.name.startswith(".")]

        # Show dirs
        for i, d in enumerate(dirs):
            is_last = (i == len(dirs) - 1) and not files
            connector = "└── " if is_last else "├── "
            child_prefix = "    " if is_last else "│   "

            # Lightweight count: only direct children, no rglob
            try:
                direct = list(d.iterdir())
                n_files = sum(1 for e in direct if e.is_file() and not e.name.startswith("."))
                n_dirs = sum(1 for e in direct if e.is_dir() and e.name not in SKIP_DIRS and not e.name.startswith("."))
                summary = f"{n_dirs} dirs, {n_files} files" if n_dirs else f"{n_files} files"
            except PermissionError:
                summary = "?"
            result.append(f"{prefix}{connector}{d.name}/ ({summary})")
            _walk(d, prefix + child_prefix, depth + 1)

        # Show file count at this level (not individual files)
        if files and depth > 0:
            result.append(f"{prefix}└── {len(files)} files")

    _walk(root, "", 0)
    return result
